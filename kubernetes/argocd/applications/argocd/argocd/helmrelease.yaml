---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: argocd
  namespace: argocd
spec:
  suspend: false  # Temporarily unsuspended to restore ArgoCD after accidental deletion
  interval: 1h
  chart:
    spec:
      chart: argo-cd
      version: 9.0.5
      sourceRef:
        kind: HelmRepository
        name: argo
        namespace: flux-system
  install:
    remediation:
      retries: 3
  upgrade:
    cleanupOnFail: true
    remediation:
      retries: 3
  values:
    global:
      domain: argocd.vaderrp.com

    server:
      # Disable ingress - we use Traefik IngressRoute instead
      ingress:
        enabled: false

      # Disable TLS certificate - Traefik handles TLS termination
      certificateSecret:
        enabled: false

      # Configure server to work behind HTTPS proxy
      config:
        # Tell ArgoCD it's behind HTTPS
        url: https://argocd.vaderrp.com

        # Disable TLS verification for internal connections
        # (Traefik handles TLS termination, backend uses HTTP)
        dex.config: |
          connectors:
          - type: oidc
            id: authentik
            name: authentik
            config:
              issuer: https://auth.vaderrp.com/application/o/argocd/
              clientID: sizSMIPV1FzETNbe25zeU9zsOuusbFXRqqQF9o0C
              clientSecret: $dex.authentik.clientSecret
              insecureEnableGroups: true
              scopes:
                - openid
                - profile
                - email

      # Service configuration
      service:
        type: ClusterIP
        port: 80

      # Disable HTTPS on the service itself
      # (Traefik handles TLS termination)
      extraArgs:
        - --insecure

    controller:
      # Standard controller config
      replicas: 1

    applicationSet:
      enabled: true
      replicas: 1

    notifications:
      enabled: false

    redis:
      enabled: true

    configs:
      cm:
        exec.enabled: "true"
        # Add health check for Flux HelmRelease resources
        resource.customizations.health.helm.toolkit.fluxcd.io_HelmRelease: |
          hs = {}
          if obj.status ~= nil then
            if obj.status.conditions ~= nil then
              for i, condition in ipairs(obj.status.conditions) do
                if condition.type == "Ready" and condition.status == "False" then
                  hs.status = "Degraded"
                  hs.message = condition.message
                  return hs
                end
                if condition.type == "Ready" and condition.status == "True" then
                  hs.status = "Healthy"
                  hs.message = condition.message
                  return hs
                end
              end
            end
          end
          hs.status = "Progressing"
          hs.message = "Waiting for HelmRelease"
          return hs
      params:
        controller.diff.server.side: "true"

    repoServer:
      volumes:
        - name: plugins
          emptyDir: {}

    # Gateway API HTTPRoute configuration
    httproute:
      enabled: true
      labels:
        route.scope: internal
      annotations:
        external-dns.alpha.kubernetes.io/public: "false"
      parentRefs:
        - name: gateway-internal
          namespace: gateway
          sectionName: https
      hostnames:
        - argocd.vaderrp.com
      rules:
        - matches:
            - path:
                type: PathPrefix
                value: /
          backendRefs:
            - name: argocd-server
              port: 80

    # Gateway API GRPCRoute configuration
    grpcroute:
      enabled: true
      labels:
        route.scope: internal
      annotations:
        external-dns.alpha.kubernetes.io/public: "false"
      parentRefs:
        - name: gateway-internal
          namespace: gateway
          sectionName: https
      hostnames:
        - argocd.vaderrp.com
      rules:
        - matches:
            - headers:
                - name: content-type
                  value: application/grpc
          backendRefs:
            - name: argocd-server
              port: 80

